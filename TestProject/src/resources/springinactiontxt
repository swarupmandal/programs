1. AOP DEF - > Aspect oriented programming is a programming technique that promotes separation of concerns within a software system.

2. page 35 - > BeanFactory beanFactory = new XmlBeanFactory("c:/beans.xml");
			   This simple line of code tells the BeanFactory to load the xml file and read bean definitions from the xml file.But it
			   doesn't instantiate beans immediately means when read xml beans are lazily loaded into BeanFactory. Means while
			   load xml immediately the beans doesn't load themselves until it is needed.
			   To get bean object from BeanFactory we have to call getBean() method. then BeanFactory will instantiates and dispense
			   bean objects with bean properties using DI and start life cycle of of the bean within Spring Container.    
			  	

3. page 36 - > [Difference] - A BeanFactory is fine for Small applications but to get original power we have to use ApplicationContext.
			   On the surface an ApplicationContext is much same as BeanFacory. Both load xml read definition collaborating beans
			   and dispense them when request comes. But ApplicationContext provide more advanced features
			 
			   i)   It supports functionality to resolve textual messages and support Internationalization.
			   ii)  It provides generic way to load file resources.
			   iii) It publish events to beans which are registered as listeners.
			   iv)  Another big difference is how singleton beans are loaded. BeanFactory loads all beans lazyli means when it read and load xml it doesn't instantiate
			   		all beans, its instantiate when request come.
					But ApplicationContext is bit intelligent it loads all the singleton beans upon context startups. So if any singleton bean
					will require in application then application doesn't need to wait to instantiate of that singleton bean.
					 			   		 
			 
4. page 37 - > There are normally three types of ApplicationContext is commonly used
			 
			   i)   ClassPathXmlApplicationContext  -> Loads a context definition from ClassPath.
			   ii)  FileSystemXmlApplicationContext ->	Loads Context definition from FileSystem.
			   iii) XmlWebApplicationContext -> Loads a context File that contained in a web application.
			 
5. 			   The difference between is that FileSystemXmlApplicationContext will find xml file in the particular location of the file system.
			   And ClassPathXmlApplicationContext will find xml file anywhere in the class path including jar files.
			   

6. page 38 - > Beans Life of beans scope.

			   A BeanFactory performs several setup steps before it is ready to use.
			   
			   Instantiate > Populate Properties > BeanNameAware's setBeanName() > BeanFactoryAwre's setBeanFactory() > 
			   
			   PreinitializationBeanPostProcessor > Initializing Bean AfterPropertiesSet() > Call Custom init method >
			   
			   PostInitializationBeanPostProcessor >[Bean is ready to use] ----> [Container is SuhtDown] >
			   
			   Disposable Bean Destroy() >call custom destroy method
			   
			   
			   STEPS TAKEN IN THE LIFECYCLE OF THE BEAN
			   
			   i)    Instantiate - > Spring instantiate the bean
			   
			   ii)   Populate Properties - > Spring injects the beans properties.
			   
			   iii)  Set Bean Name - > If the bean implements BeanNameAwre, Spring passes id to set beanName();
			   
			   iv)   Set bean Factory - > If the bean implements BeanFactoryAwre then spring passes the
			   		 beanFactory to setBeanFactory
			   		 
			   v)	 PostProcessor(before initialization) - > if there are any BeanPostProcessor bean calls there
			    	 postProcessorBeforeInitialization method.
			    	 
			   vi)   Initialize beans - > if a bean implements InitializingBean, afterPropertiesSet() will be called, if
			    	 any other custom init method declared then that method will be called.
			    
			   vii)  Postprocess After initialization -> If there is any BeanPostProcessors then Spring will called postProcessAfterInitialization()
			    
			  viii)	 Bean Is Ready to use - > At this point bean is ready to use and if it is not called from anywhere in application then
			         it will remain same.	 
			         
			         
7. page 41 - > 		The <bean/> element is the most basic Configuration unit in spring framework. It tells spring to create an object of them.

			         <bean id="duke" class="com.springinaction.springidol.Juggler"/>
					
					The id attribute gives a name by which supply reference to the spring container.
					
8. page 45 - > Constructor or setter injection: how do you choose?
			 	
			   > Spring doesn't take side of either constructor or setter injection. We can also mix constructor and setter in a single bean.
			     but I found when the dependencies are strict we can choose constructor di and when dependencies or properties are not
			     fixed in object creation then we should go for setter injection.
			     
			    <!-- Setter Injection -->
			      
			    <bean id="kenny" class="org.spr.model.Instrumentalist">
					<property name="song" value="My heart will go on..."></property>
					<property name="instrument" ref="guiter"></property>
				</bean>
	
				<bean id="piano" class="org.spr.model.Piano"></bean>
				<bean id="guiter" class="org.spr.model.Guiter"></bean>
			     
			    <!-- constructor Injection -->
			     
			    <bean id = "kenny" class = "">
			    	<constructor-args value ="15"/>
			    	<constructor-args ref ="guiter"
			    
			    </bean>  
			    <bean id="guiter" class="org.spr.model.Guiter"></bean> 
			     
			     
9. page 48 - > In case of constructor dependency injection
			   spring is doing as
			   int a;
			   Food food;
			   
			   Animal animal = new Cat(a, food);
			   
			   
			   In case of setter dependency injection
			   Spring first read the name of the value and on that it is calling its setter method and injecting the value.before injecting its value
			   spring converts type of the value as the property type and after that it inject.
			   
			   Cat cat = new Cat();
			   cat.setA(1);
			   
			   The main difference between java setter and spring setter is
			   Spring is doing it in decoupled way. we can change the value as many time required but in case of java setter to change value need to
			   change manually in java class.
			   
10.	page 52 -> inner bean

			   If we want to restrict any bean object to only one bean then we go for inner bean concept. here the reference of the bean is not available
			   to other beans. So the disadvantage is it is not reusable. Inner beans are only useful for injection only one class and can't be referred to
			   by others.
			   
			   <bean id= "kenny" value = "org.spr.model.Instrumentalist">
			   		<property name = "song" value = "Too Too Too.."/>
			   		<property name = "instrument">
			   			<bean class = "org.spr.model.Piano"/>
			   		</property>	
			   </bean>  
			   			   
			   <bean id= "kenny" value = "org.spr.model.Instrumentalist">
			   		<constructor-args value = "15"/>
			   		<constructor-args>
			   			<bean class = "org.spr.model.Piano"/>
			   		</constructor-args>	
			   </bean>    							
							
							
11. page 52 -> wiring collections

12. page 58 -> Autowiring

			   primitive types are not auto wiring.

		       In case of large application explicit autowiring will need to write a lot of xmls. Spring can automatically figure out how to wire beans
		       together by setting the autowire properties on each <bean/> that need to autowire by spring.
		       
		       four types of autowiring is there
		       
		       i)   byName - Attempts to find the name(or id) of the bean in the container whose name will be matched with the name of the property
		                     is being matched. If no matching name is found then the bean will unwired.
		                    
			   ii)  byType - Attempting to find a single bean in the container with the same type that is being wired with the property. If no matching
			                 found it will unwired. If more than one bean of same type found it will throw UnsatisfiedDependencyException.
			                 
			   iii) constructor - Tries to match up with multiple beans with bean properties defined. if more than one same constructor found
			                      then UnsatisfiedDefinitionException will throw.
			                      
			   iv) autoDetect - Attempts to autowired by constructor first after that byType.                                 
			   

   page 59 - Autowiring byName -
   			 
   			 <bean id="kenny" class="com.springinaction.springidol.Instrumentalist" autowire="byName">
				<property name="song" value="Jingle Bells" />
			 </bean>
			 
			 <bean id="instrument" class="com.springinaction.springidol.Saxophone" />
			 
			 byName is having one limitation if multiple bean is having the same name then all bean will treat as same. but it is very rare.
			 
			 
   			 Autowiring byType -
   			 
   			 In case of ambiguity spring will not guess the proper bean it will throw an exception.
   			 if many classes implements one interface then bytype autowiring will throw exception.
   			 
   			 
   			 
   			 Using constructor autowiring -
   			 
   			 Autowiring by constructor shares the same limitations as byType. That is,
			 Spring will not attempt to guess which bean to autowire when it finds multiple
			 beans that match a constructor’s arguments. Furthermore, if a constructor has
			 multiple constructors, any of which can be satisfied by autowiring, Spring will not
		     attempt to guess which constructor to use.
   			 
   			 Autodetect autowiring
   			 
   			 If you want to autowire your beans, but you can’t decide which type of autowiring
			 to use, have no fear. By setting the autowire attribute to autodetect.
			 When a bean has been configured to autowire by autodetect, Spring will attempt
		     to autowire by constructor first. If a suitable constructor-bean match can’t be
             found then Spring will attempt to autowire by type
   			 
   			 			
			 If we want same auto wiring for all beans then we can go for auto-detect autowiring.
			 
			 <beans default-autowire="byName">
			
			 </beans>  							
			 				
			 		         
13. Controlling Bean Creation ->
				
			 i)   Control how many instances of a specific bean will create, whether it will create a single bean through out the application
			      or it will create a new instance for every request or a new instance each time you use.
			   
			 ii)  Create bean from static factory method instead of constructor.
			  
			 iii) Initializing after it is created and clean up just before destroying.
			  
14. page 65 - Bean Scoping - >
						     By default all spring beans are singleton.Means when a container dispense a bean it will always returns exact same bean every time
							 whether the bean is creating through wiring or getBean() method.
							 
							 To Generate new bean instance each call we have to override the singleton nature of spring.
							 For that we have to declare bean as scope = "prototype".
							 
							 singleton - Scopes the bean definition to single per container (default)
							 
							 prototype - Allows the bean to each time new instance.
							 
							 session - Scopes a bean definition to an Http session.
							 
							 request - Scopes a bean definition per Http request.
							 
							 global-session - Scopes a bean definition to global Http session.
							 
							 
							 
15. page 66 - Creating beans from factory methods - >
              
              Normally Spring container instantiating beans through default constructor of bean class.
              But what happen when we will use a third party bean and that is not having any constructor it is instantiating beans through static factory method.
              In this case <bean/> is having one attribute
              factory-method = ""  				 
    		  here we have to pass method name of that class.
    		  
    		  <bean id = "stage" class = "..Stage.class" factory-method = "getInstance" />
    		  
    		           
16. page 68 - Initializing and Destroying bean - >

			  When bean is initializing it may need to perform some task to get into an usable state.when been is destroying it may need to perform some
			  clean up task before destroying.
			  
			  for that <bean/> is having two attributes
			  i) init-method
			  ii)destroy-method
			  
			  <bean id="kenny" class="com.springinaction.springidol.Instrumentalist"
									init-method="tuneInstrument" destroy-method="cleanInstrument">
			  <property name="song" value="Jingle Bells" />
		      <property name="instrument" ref="saxophone" />
		      </bean>
		      
		      we have two handy attributes in <beans/> tag. We can set default attribute for all beans in the container if they have the same method name
		      then it will perform init and destroy task.
		      
		      <?xml version="1.0" encoding="UTF-8"?>
				<beans xmlns="http://www.springframework.org/schema/beans"
					xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
					xsi:schemaLocation="http://www.springframework.org/schema/beans
					http://www.springframework.org/schema/beans/spring-beans-2.0.xsd"
					default-init-method="tuneInstrument"
					default-destroy-method="cleanInstrument">
					…
				</beans>
				
17. InitializingBean and DisposableBean page 69 - > Its a special kind of Interface when a class implements this interface class needs to
													override afterPropertiesSet() method and destroy() method.
													And spring container confirms that it will perform init method after setting all of its properties.
													
													And in case of destroy method spring container confirms that after cleaning up task only bean destruction
													will perform.
													
													But normally it is not recommended because it will create coupling.
													
													
								 					
								 					
								 
								 				 				 			   				    	 
			    
			   	

			
			   		   
			     	 
			   