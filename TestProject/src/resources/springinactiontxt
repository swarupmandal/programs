1. AOP DEF - > Aspect oriented programming is a programming technique that promotes separation of concerns within a software system.

2. page 35 - > BeanFactory beanFactory = new XmlBeanFactory("c:/beans.xml");
			   This simple line of code tells the BeanFactory to load the xml file and read bean definitions from the xml file.But it
			   doesn't instantiate beans immediately means when read xml beans are lazily loaded into BeanFactory. Means while
			   load xml immediately the beans doesn't load themselves until it is needed.
			   To get bean object from BeanFactory we have to call getBean() method. then BeanFactory will instantiates and dispense
			   bean objects with bean properties using DI and start life cycle of of the bean within Spring Container.    
			  	

3. page 36 - > [Difference] - A BeanFactory is fine for Small applications but to get original power we have to use ApplicationContext.
			   On the surface an ApplicationContext is much same as BeanFacory. Both load xml read definition collaborating beans
			   and dispense them when request comes. But ApplicationContext provide more advanced features
			 
			   i)   It supports functionality to resolve textual messages and support Internationalization.
			   ii)  It provides generic way to load file resources.
			   iii) It publish events to beans which are registered as listeners.
			   iv)  Another big difference is how singleton beans are loaded. BeanFactory loads all beans lazyli means when it read and load xml it doesn't instantiate
			   		all beans, its instantiate when request come.
					But ApplicationContext is bit intelligent it loads all the singleton beans upon context startups. So if any singleton bean
					will require in application then application doesn't need to wait to instantiate of that singleton bean.
					 			   		 
			 
4. page 37 - > There are normally three types of ApplicationContext is commonly used
			 
			   i)   ClassPathXmlApplicationContext  -> Loads a context definition from ClassPath.
			   ii)  FileSystemXmlApplicationContext ->	Loads Context definition from FileSystem.
			   iii) XmlWebApplicationContext -> Loads a context File that contained in a web application.
			 
5. 			   The difference between is that FileSystemXmlApplicationContext will find xml file in the particular location of the file system.
			   And ClassPathXmlApplicationContext will find xml file anywhere in the class path including jar files.
			   

6. page 38 - > Beans Life of beans scope.

			   A BeanFactory performs several setup steps before it is ready to use.
			   
			   Instantiate > Populate Properties > BeanNameAware's setBeanName() > BeanFactoryAwre's setBeanFactory() > 
			   
			   PreinitializationBeanPostProcessor > Initializing Bean AfterPropertiesSet() > Call Custom init method >
			   
			   PostInitializationBeanPostProcessor >[Bean is ready to use] ----> [Container is SuhtDown] >
			   
			   Disposable Bean Destroy() >call custom destroy method
			   
			   
			   STEPS TAKEN IN THE LIFECYCLE OF THE BEAN
			   
			   i)    Instantiate - > Spring instantiate the bean
			   
			   ii)   Populate Properties - > Spring injects the beans properties.
			   
			   iii)  Set Bean Name - > If the bean implements BeanNameAwre, Spring passes id to set beanName();
			   
			   iv)   Set bean Factory - > If the bean implements BeanFactoryAwre then spring passes the
			   		 beanFactory to setBeanFactory
			   		 
			   v)	 PostProcessor(before initialization) - > if there are any BeanPostProcessor bean calls there
			    	 postProcessorBeforeInitialization method.
			    	 
			   vi)   Initialize beans - > if a bean implements InitializingBean, afterPropertiesSet() will be called, if
			    	 any other custom init method declared then that method will be called.
			    
			   vii)  Postprocess After initialization -> If there is any BeanPostProcessors then Spring will called postProcessAfterInitialization()
			    
			  viii)	 Bean Is Ready to use - > At this point bean is ready to use and if it is not called from anywhere in application then
			         it will remain same.	 
			         
			         
7. page 41 - > 		The <bean/> element is the most basic Configuration unit in spring framework. It tells spring to create an object of them.

			         <bean id="duke" class="com.springinaction.springidol.Juggler"/>
					
					The id attribute gives a name by which supply reference to the spring container.
					
8. page 45 - > Constructor or setter injection: how do you choose?
			 	
			   > spring container resolves dependencies at the time of instantiation.
			 	
			   > Spring doesn't take side of either constructor or setter injection. We can also mix constructor and setter in a single bean.
			     but I found when the dependencies are strict we can choose constructor di and when dependencies or properties are not
			     fixed in object creation then we should go for setter injection.
			     
			    <!-- Setter Injection -->
			      
			    <bean id="kenny" class="org.spr.model.Instrumentalist">
					<property name="song" value="My heart will go on..."></property>
					<property name="instrument" ref="guiter"></property>
				</bean>
	
				<bean id="piano" class="org.spr.model.Piano"></bean>
				<bean id="guiter" class="org.spr.model.Guiter"></bean>
			     
			    <!-- constructor Injection -->
			     
			    <bean id = "kenny" class = "">
			    	<constructor-args value ="15"/>
			    	<constructor-args ref ="guiter"
			    
			    </bean>  
			    <bean id="guiter" class="org.spr.model.Guiter"></bean> 
			     
			     
9. page 48 - > In case of constructor dependency injection
			   spring is doing as
			   int a;
			   Food food;
			   
			   Animal animal = new Cat(a, food);
			   
			   
			   In case of setter dependency injection
			   Spring first read the name of the value and on that it is calling its setter method and injecting the value.before injecting its value
			   spring converts type of the value as the property type and after that it inject.
			   
			   Cat cat = new Cat();
			   cat.setA(1);
			   
			   The main difference between java setter and spring setter is
			   Spring is doing it in decoupled way. we can change the value as many time required but in case of java setter to change value need to
			   change manually in java class.
			   
10.	page 52 -> inner bean

			   If we want to restrict any bean object to only one bean then we go for inner bean concept. here the reference of the bean is not available
			   to other beans. So the disadvantage is it is not reusable. Inner beans are only useful for injection only one class and can't be referred to
			   by others.
			   
			   <bean id= "kenny" value = "org.spr.model.Instrumentalist">
			   		<property name = "song" value = "Too Too Too.."/>
			   		<property name = "instrument">
			   			<bean class = "org.spr.model.Piano"/>
			   		</property>	
			   </bean>  
			   			   
			   <bean id= "kenny" value = "org.spr.model.Instrumentalist">
			   		<constructor-args value = "15"/>
			   		<constructor-args>
			   			<bean class = "org.spr.model.Piano"/>
			   		</constructor-args>	
			   </bean>    							
							
							
11. page 52 -> wiring collections

12. page 58 -> Autowiring

			   primitive types are not auto wiring.

		       In case of large application explicit autowiring will need to write a lot of xmls. Spring can automatically figure out how to wire beans
		       together by setting the autowire properties on each <bean/> that need to autowire by spring.
		       
		       four types of autowiring is there
		       
		       i)   byName - Attempts to find the name(or id) of the bean in the container whose name will be matched with the name of the property
		                     is being matched. If no matching name is found then the bean will unwired.
		                    
			   ii)  byType - Attempting to find a single bean in the container with the same type that is being wired with the property. If no matching
			                 found it will unwired. If more than one bean of same type found it will throw UnsatisfiedDependencyException.
			                 
			   iii) constructor - Tries to match up with multiple beans with bean properties defined. if more than one same constructor found
			                      then UnsatisfiedDefinitionException will throw.
			                      
			   iv) autoDetect - Attempts to autowired by constructor first after that byType.                                 
			   

   page 59 - Autowiring byName -
   			 
   			 <bean id="kenny" class="com.springinaction.springidol.Instrumentalist" autowire="byName">
				<property name="song" value="Jingle Bells" />
			 </bean>
			 
			 <bean id="instrument" class="com.springinaction.springidol.Saxophone" />
			 
			 byName is having one limitation if multiple bean is having the same name then all bean will treat as same. but it is very rare.
			 
			 
   			 Autowiring byType -
   			 
   			 In case of ambiguity spring will not guess the proper bean it will throw an exception.
   			 if many classes implements one interface then bytype autowiring will throw exception.
   			 
   			 
   			 
   			 Using constructor autowiring -
   			 
   			 Autowiring by constructor shares the same limitations as byType. That is,
			 Spring will not attempt to guess which bean to autowire when it finds multiple
			 beans that match a constructor’s arguments. Furthermore, if a constructor has
			 multiple constructors, any of which can be satisfied by autowiring, Spring will not
		     attempt to guess which constructor to use.
   			 
   			 Autodetect autowiring
   			 
   			 If you want to autowire your beans, but you can’t decide which type of autowiring
			 to use, have no fear. By setting the autowire attribute to autodetect.
			 When a bean has been configured to autowire by autodetect, Spring will attempt
		     to autowire by constructor first. If a suitable constructor-bean match can’t be
             found then Spring will attempt to autowire by type
   			 
   			 			
			 If we want same auto wiring for all beans then we can go for auto-detect autowiring.
			 
			 <beans default-autowire="byName">
			
			 </beans>  							
			 				
			 		         
13. Controlling Bean Creation ->
				
			 i)   Control how many instances of a specific bean will create, whether it will create a single bean through out the application
			      or it will create a new instance for every request or a new instance each time you use.
			   
			 ii)  Create bean from static factory method instead of constructor.
			  
			 iii) Initializing after it is created and clean up just before destroying.
			  
14. page 65 - Bean Scoping - >
						     By default all spring beans are singleton.Means when a container dispense a bean it will always returns exact same bean every time
							 whether the bean is creating through wiring or getBean() method.
							 
							 To Generate new bean instance each call we have to override the singleton nature of spring.
							 For that we have to declare bean as scope = "prototype".
							 
							 singleton - Scopes the bean definition to single per container (default)
							 
							 prototype - Allows the bean to each time new instance.
							 
							 session - Scopes a bean definition to an Http session.
							 
							 request - Scopes a bean definition per Http request.
							 
							 global-session - Scopes a bean definition to global Http session.
							 
							 
							 
15. page 66 - Creating beans from factory methods - >
              
              Normally Spring container instantiating beans through default constructor of bean class.
              But what happen when we will use a third party bean and that is not having any constructor it is instantiating beans through static factory method.
              In this case <bean/> is having one attribute
              factory-method = ""  				 
    		  here we have to pass method name of that class.
    		  
    		  <bean id = "stage" class = "..Stage.class" factory-method = "getInstance" />
    		  
    		           
16. page 68 - Initializing and Destroying bean - >

			  When bean is initializing it may need to perform some task to get into an usable state.when been is destroying it may need to perform some
			  clean up task before destroying.
			  
			  for that <bean/> is having two attributes
			  i) init-method
			  ii)destroy-method
			  
			  <bean id="kenny" class="com.springinaction.springidol.Instrumentalist"
									init-method="tuneInstrument" destroy-method="cleanInstrument">
			  <property name="song" value="Jingle Bells" />
		      <property name="instrument" ref="saxophone" />
		      </bean>
		      
		      we have two handy attributes in <beans/> tag. We can set default attribute for all beans in the container if they have the same method name
		      then it will perform init and destroy task.
		      
		      <?xml version="1.0" encoding="UTF-8"?>
				<beans xmlns="http://www.springframework.org/schema/beans"
					xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
					xsi:schemaLocation="http://www.springframework.org/schema/beans
					http://www.springframework.org/schema/beans/spring-beans-2.0.xsd"
					default-init-method="tuneInstrument"
					default-destroy-method="cleanInstrument">
					…
				</beans>
				
17. page 69 - InitializingBean and DisposableBean - > Its a special kind of Interface when a class implements this interface class needs to
													override afterPropertiesSet() method and destroy() method.
													And spring container confirms that it will perform init method after setting all of its properties.
													
													And in case of destroy method spring container confirms that after cleaning up task only bean destruction
													will perform.
													
													But normally it is not recommended because it will create coupling.
													
													
													
													
													
															CHAPTER 3
														   -----------
														   


1. page 75 - Declaring parent and child beans - >

			 parent - indicates the id of a <bean/> that will be the parent of the <bean/> with the parent attribute.
			 
			 abstract - If it set true then the bean become abstract and it never be instantiated in by spring.
			 
			 
			 Inheritance helps to keep common properties in a parent bean and other beans should extends that parent bean. and help sub beans to less code.
			 
			 <bean id = "baseSaxophonist" class = "...Instrumentalist" abstract = "true">
			 	<property-name = "song" value = "Jingle bale"/>
			 	<property-name = "instrument" ref = "guitar"/>
			 </bean>
			 
			 <bean id = "kenny" parent = "baseSaxophonist"/>
			 <bean id = "devid" parent = "baseSaxophonist"/>
			 
			 //here no class is there
			 
			 Here we are using all the properties of parent bean.But if we want to take only few properties we can and also overrides parent properties.
			 	
			 <bean id = "frank" parent = "baseSaxophonist">
			 	<property-name = "song" value = "oh my love"/>
			 </bean>
			 
			 here we overrides the song property.
			 
			 
			  														   
page 76 - Abstracting common properties - >
	
		  It is possible in spring to common properties in a bean with out any type(class).And it acts as a parent class and any types of bean can'
		  inherit this.
		  
		  <bean id = "basePerformer" abstract = "true">
		  	<property-name = "song" value = "Somewhere over rainbow"/>
		  </bean>	  																			
								 					
		  <bean id = "tailor"
		        class = "..Vocalist"
		        parent = "basePerformer"/>
		        
		  <bean id = "kenny" class = "..Instrumentalist" parent = "basePerformer">
		  	<property name="instrument" ref = "guitar"/>
		  </bean>
		  
		  here basePerformer is a parent bean and it is an abstract bean. ant types of beans are extending it.
		  
2. page 78 - Applying method injection ->

			 i) method replacement - > Enables existing methods replacement with another method implementation runtime.
			 						   In this case bean class should implement MethodReplacer class of spring framework and override
			 						   reimplement() method.
			 						   this method takes parameter the target object thats the method will be replaced on,
			 						   							   method name
			 						   							   argument passed to the method(if required)
			 						   							   
			 						   							   								 		 
			 ii)getter Injection - >  Its special type of method injection where a a method declared(normally abstract method) to return certain types of bean.
			 						  But the actual returned bean is configure in spring context.
			 						  
			 	 		  		      
		     Method replacement is not allowed to change method signature.
		     
		     Method replacement is useful when A bean is singleton and its property bean is prototype then instead of dependent bean is prototype because of
		     main bean singleton every time calling dependent bean it also return same bean every time.
		     In this case if we want to get a new instance of dependent bean every time we then method injection is useful.
		     
		     

3. page 85 - Injecting non-Spring beans - >
			 								 
			 In this spring concept beans are configuring by spring and instantiated out side of the container.
			 Spring configuration just plays a template or blue print of that bean.
			 
			 Here in configuration we have to make <bean/> abstract = "true"
			 means we don't want to instantiate bean by spring.
			 
			 <bean id = "pianist" class = "..Instrumentalist" abstract = "true">
			 	<property name = "song" value = "Too Too Too Too.."/>
			 	<property name = "instrument">
			 		<bean class = "..Piano"/>  					 				 				 			   				    	 
			    </property>
			 </bean>
			 
			 here pianist beans only serves a blue print of Intrumentalist that is created out side of the spring. With this blue print we need some
			 way to associate it with Instrumentalist class
			 and that is @Configurable
			 
			 @Configurable("pianist")
			 class Instrumentalist {
			 
			 }
			 
			 @Configurable doing two things
			 
			 i)  Declaring this annotation spring we saying to spring that spring no need to instantiate this bean.
			 	 It will be created in outside of spring container. 
			 
			 ii) It also associates the Instrumentalist class with bean whose Id is "pianist" and this bean
			     will works as a template.
			     
			     
4. page 89 - Registering custom property editors - >
			 
			 The java beans PropertyEditor Interface provides a means to customize how string values are mapped to non-string types.
			 this interface hsa two methods getAsText() and setAsText()
			 
			 getAsText() - returns the string representation of property values
			 
			 setAsText(String str ) - sets a bean property value from the string to it.
			 
			 
5. page 93 - Postprocessing beans - >

			 useful to alter bean configuration	

			 Spring offers two opportunities to cut into bean's life cycle process and review or alter bean configuration. This can be happen after
			 occurring some events. This postProcessing follows bean instantiation and configuration.
			 
			 After spring container finishes configuring, instantiating and initializing we can implement some custom logic by plugging in
			 one or more BeanPostProcessor implementation.We can implement multiple BeanPostProcessor and we can control the execution order
			 of BeanPostProcessor by setting the order property BeanPostProcessor implements Order interface.
			 
			 The BeanPostProcessor operates on bean instances means after instantiated by spring container
			 means after instantiating beans by container BeanPostProcessor starts working.  
			 BeanPostProcessor is used to interact with beans after or before initialization method is invoked by Spring container.
			 we can use BeanPostProcessor to execute custom logic after/before invoking initialization method by spring container.
			 
			 
			 
			 
			 BeanPostProcessor interface provides two methods to alter bean configuration.
			 
			 Object postProcessBeforeInitialization(Object bean, String name) throws BeansException
			 
			 Object postProcessAfterInitialization(Object bean, String name) throws BeansException
			 
			 The postProcessBeforeInitialization method calls prior to bean initialization invoked by container.
			 and postProcessAfterInitialization method calls immediately after bean initialization by container. 

			 BeanPostProcessor's methods takes the newly created bean and its name as arguments and returns same or modified bean.
			 We can write BeanPostProcessor's in application context as other beans. After creating BeanPostProcessor object container will call
			 each BeanPostProcessor's methods for each bean instance created by container.


 			 >> Writing a bean postprocessor -
 			 
 			 Suppose need to alter all String properties of application to translate them into Elmer Fudd-speak.
 			 The Fuddifier class is doing just this
 			 
 			 public class Fuddifier implements BeanPostProcessor {
 			 
 			 	public Object postProcessAfterInitialization(Object bean, String name) throws BeansException{
 			 		
 			 		Field[] fields = bean.getClass().getDeclaredFields();
 			 		
 			 		try {
 			 			for(int i =0; i< fields.lemgth; i++){
 			 				
 			 				if(fields[i].getClass.equals(java.lang.String.calss)){
 			 					
 			 					fields[i].setAccsessable(true);
 			 					String original = (String)fields[i].get(bean);
 			 					fields[i].set(bean, fuddify(original));
 			 				}
 			 			
 			 			
 			 			}
 			 			
 			 		
 			 		}catch(IllegalAccessException e){
 			 			e.printStackTrace();
 			 		}
 			 		return bean;
 			 	}
 			 	
 			 	private String fuddify(String original){
 			 	
 			 		if(original == null) return original;
 			 		return orig.replaceAll("(r|l)", "w")
					.replaceAll("(R|L)", "W");
 			 	}
 			 	
 			 	public Object postProcessBeforeInitialization(Object bean, String name) throws BenasException{
 			 	
 			 	
 			 		return bean;
 			 		
 			 	}
 			 	
 			 	
 			 }  
			 
			 >> Registering bean postprocessors -
			 
			 Example of spring's own BeanPostProcessor is ApplicationContextAwareProcessor. 
			 
			 	


6. page no - 96 Externalizing configuration properties - >

				PropertyPlaceholderConfigurer enables externalizing configuration values into property file and loading those values into placeholder
				variables in spring context definition.
				
				
7. page no - 99 Message Resolver - >

			    ResourceBundleMessageResouce use to resolve messages.
			    
8. page no - 101 Decoupling with application events - >
	
				 In spring we can decouple object by dependency injection. There is another way to decouple objects using event publisher and event listener.
				 In this way one bean can communicate with another bean with out knowing each other.
				 Ex - One radio station is not connected directly through wired with each radio. and also it is unknown about which of the radio
				 	  tuned with which station it is just publishing events and radios are listening that event.
				 	  
				 	  Any bean can be a event publisher or listener or both.
				 	  
				 
				 
				 	  
				 	  							CHAPTER - 5
				 	  						   -------------
				 	  						   
HITTING DATABASE - PAGE NO 155



1. page 165 - Configuring a data source - > 
		
			  i)  data sources that defined by JDBC Driver.
			  ii) data sources that are looks up by JNDI.
			  iii)data sources that defined in a connection pool.
			  
			  	

2. i) Using JNDI data source - >
			  
			  Spring applications often deployed in jee application servers like jboss, webSphere or simple tomcat server. These servers allow us
			  to configure data source through JNDI. The advantage of jndi data source is it is completely manageble from outside of the application
			  and leaving application to simply ask for data source when it is completely ready for accessing databse.
			  
			  with spring we can configure a reference to a data source and that kept it in a JNDI and wire it to the class just like a simple
			  spring bean.
			  Spring's JNDIObjectFactoryBean makes it possible to retrieve any object including data source from JNDI and make it availvle
			  as a spring bean.
			  
			  <bean id = "dataSource" value = "org.springframework.jndi.JNDIObjectFactoryBean" scope ="singleton">
			  	<property name = "jndiName" value = "/jdbc/RantzDatasource"/>
			  	<property name = "resourceRef" value = "true" />
			  </bean>	 			  	

			  The jndiName attribute used to specify the name of the resource in JNDI.If the jndiName property is set then data source looked up as is.
			  If resourceRef set as true the value of jndiName will prepend with java:comp/env to retrieve data source as a java source from the
			  application server's JNDI directory. Consequently, the actual name will be java:comp/env/jdbc/RantzDatasource.
			  
			  The jee namespace provides <jee:jndi-lookup> element for retrieving data from jndi. Following xml is serving the same task
			  as JndiObjectFactoryBean.
			  
			  <jee:jndi-lookup id = "dataSource"
			  jndi-name = "/jdbc/RantzDataSourec"
			  resource-ref = "true" />
			  
			  
			  
	ii) Using a pooled data source - >
              
              If unable to retrieve datasource from JNDI then the best way is cofigure a pooled datasource directly in spring.Spring is not
              provide pooled data source but we can have very handy apache jakarta database connection pools. we have to use jar file or
              add meven dependency.
              
              <bean id="dataSource"
					class="org.apache.commons.dbcp.BasicDataSource">
					<property name="driverClassName" value="org.hsqldb.jdbcDriver" />
					<property name="url"
					value="jdbc:hsqldb:hsql://localhost/roadrantz/roadrantz" />
					<property name="username" value="sa" />
					<property name="password" value="" />
					<property name="initialSize" value="5" />
					<property name="maxActive" value="10" />
			  </bean>
			  
			  Here data source is proving by BasicDataSource. we have confugured with pooled datasource with 5 connection and 10 max active connecection.
			   
              
	iii) JDBC driver-based data source - >
		      
		      The simpliest datasource we can configure in spring is one that is defined through a jdbc driver.spring provide two datasource classes
		      in org.springframework.jdbc.datasource package.
		      
		      > DriverManagerDataSource - It provides everytime a new connection when a connection is requested. Unlike DBCP's BasicDataSource it is not
		                                  a pooled connection.
		                                  
		      > SingleConnectionDataSource - It provides same connection everytime when a connection is requested.
		      								 It acts as a connection pool of a single connection.
		      
		      Configuration either of classes is as same as DBCP's BasicDataSource.
		      
		      <bean id="dataSource"
					class="org.springframework.jdbc.datasource.DriverManagerDataSource">
					<property name="driverClassName"
					value="org.hsqldb.jdbcDriver" />
					<property name="url"
					value="jdbc:hsqldb:hsql://localhost/roadrantz/roadrantz" />
					<property name="username" value="sa" />
					<property name="password" value="" />
			  </bean>
			  
			  The only difference is these classes not providing connection pooling, we don't need to add other configurations.
			  
			  Although these datasources are well for small application, being a single connection class SingleConnectionDataSource
			  will not applicable for multithreaded environment.
			  
			  And though DriverManagerDataSource creates new connection on each request it incurs a performence cost on creating new connection
			  each request. 
			  Connection Pooling is recomended.
			  
			  								 
		      								 
3. page - 170 Using JDBC with Spring - >

		      
		      using jdbc with spring allow us to work and having control on all operations. but one very big problem is we have to write much code
		      and need to handle all operations from connection open to close, resource management, transaction, exception handling.
		      		      								 
		      
4. page - 174 Working with JDBC templates - >
				
			  Spring's JDBC framework souldering the burden of resource management and Exception handling. This leavs you free write codes to move
			  data from and to database.
			  Spring abstract the boiler plate code behind template classes. Spring provides three types of jdbc template classes
			  
			  i)   JdbcTemplate - It provides simple access to database through jdbc connection and simple indexed base parameter sql.
			  
			  ii)  NamedParmeterJdbcTemplate - It enables to perform queries where values are bound to named parameter.
			  
			  iii) SimpleJdbcTemplate - This version of jdbc template uses java 5 features and varible parameters  lists to simplify how
			       a jdbc template is used.
			       
			  Which one will be choosen is largely a matter of performence.     
			  

			  > Accessing data using JdbcTemplate
			  
			  All a JDBC template needs to do its work is DataSource.
			  It is easy to configure jdbc template in spring xml as a bean.
			  
			  <bean id="dataSource"
					class="org.springframework.jdbc.datasource.DriverManagerDataSource">
					<property name="driverClassName"
					value="org.hsqldb.jdbcDriver" />
					<property name="url"
					value="jdbc:hsqldb:hsql://localhost/roadrantz/roadrantz" />
					<property name="username" value="sa" />
					<property name="password" value="" />
			  </bean>
			  
			  <bean id = "jdbcTemplate" class = "org.springframework.jdbc.core.JdbcTemplate">
			  	<property name = "datasource" ref = "dataSource"/>
			  </bean>	
			   
			  datasource property can be any implementation of javax.sql.DataSource.
			  
			  now we can write JdbcTemplate in our Dao class.
			  
			  public class JdbcRantDao implements RantDao {
			  
			  private JdbcTemplate jdbcTemplate;
			  
			  .
			  .
			  .
			  
			  public void setJdbcTemplate(JdbcTemplate jdbcTemplate){
			  		
			  		this.jdbcTemplate = jdbcTemplate;			  		
			  
			  }
			  
			  }


			  <bean id = "rantDao" class ="..JdbcRantDao" >
			  	<property name = "jdbcTemplate" ref = "jdbcTemplate"/>
			  </bean>
			  
			  with jdbc template the db operation is like this
			  
			  private static final String MOTORIST_INSERT =
					"insert into motorist (id, email, password, " +
					"firstName, lastName) " +
					"values (null, ?,?,?,?)";
					
					public void saveMotorist(Motorist motorist) {
					
					jdbcTemplate.update(MOTORIST_INSERT, new Object[] { motorist.getEmail(),motorist.getPassword(),
					motorist.getFirstName(), motorist.getLastName() });
			  }

			  
			  Here no need to create connection, no need to handle exception. Here connection creation, statement creation and execution is
			  hidden by JdbcTemplate.
			  JdbcTemplate catches the exceptions converts into more specific data access exception and re throws. All are runtime exceptions.
			  
			  Reading data also very simple in JdbcTemplate. It uses jdbc callbacks to map resultsets with domain object.
			  
			  
			  private static final String MOTORIST_SELECT = "select id, email, password, firstName, lastName from motorist";
			  
					private static final String MOTORIST_BY_ID_SELECT = MOTORIST_SELECT + " where id=?";
					
					public Motorist getMotoristById(long id) {
					
					List matches = jdbcTemplate.query(MOTORIST_BY_ID_SELECT,new Object[] { Long.valueOf(id) },new RowMapper() {
					
					               public Object mapRow(ResultSet rs, int rowNum) throws SQLException, DataAccessException {
					
								   Motorist motorist = new Motorist();
								   motorist.setId(rs.getInt(1));
								   motorist.setEmail(rs.getString(2));
								   motorist.setPassword(rs.getString(3));
								   motorist.setFirstName(rs.getString(4));
								   motorist.setLastName(rs.getString(5));
								   
								return motorist;
								}
					});
					
					return matches.size() > 0 ? (Motorist) matches.get(0) : null;
				}
				
				
				
				mapRow() method takes three parameters sql, object array of parameter index based, RowMapper object that extract ta result from ResultSet.
				
				here the importaint is rowMap() method. For every row extracted by query rowMap() method will call. within that method we have to write
				domain object population code, with that data getting from ResultSet.
				
				get value method is not having any resource management code and Exception handling code.
				
				
				
				> Using named parameters
				
				In case of index based there is a problem with parameters. During code we have to notice the sql parameter index every time if
				any changes is there we have to chane the index also.
				For that we have an option to avoid index based parameter is named base parameter.
				Here we no need to notice the indexes of parameter and we can pass values through name.
				
				But Jdbc template is not providing this facility. The NamedParameterJdbcTemplate is providing this facility.
				And it is not extends from JdbcTemplate we have to change configuration and classes.
				
				<bean id="jdbcTemplate" class="org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate">
					<property name="dataSource" ref="dataSource" />
				</bean>
				
				private static final String MOTORIST_INSERT =" insert into motorist (id, email, password, " +
															 " firstName, lastName) " +
															 " values (null, :email, :password, :firstName, :lastName)";
															 
				
				public class JdbcRantDao implements RantDao {
					private NamedParameterJdbcTemplate jdbcTemplate;
					public void setJdbcTemplate(NamedParameterJdbcTemplate jdbcTemplate) {
					this.jdbcTemplate = jdbcTemplate;
										
					}
				
				
				public void saveMotorist(Motorist motorist) {
				
						Map parameters = new HashMap();
						parameters.put("email", motorist.getEmail());
						parameters.put("password", motorist.getPassword());
						parameters.put("firstName", motorist.getFirstName());
						parameters.put("lastName", motorist.getLastName());
						jdbcTemplate.update(MOTORIST_INSERT, parameters);
				
					}

				}
				
				we have to use map to use named parameter.
				
				
				
				
				> Simplifying JDBC in Java 5
				
				  This is taking advantages of java 5 varargs and generics and using SimpleJddbcTemplate.
				  
				  <bean id="jdbcTemplate" class="org.springframework.jdbc.core.simple.SimpleJdbcTemplate">
						<property name="dataSource" ref="dataSource" />
				  </bean>
				  
				  public class JdbcRantDao implements RantDao {
					…
					private SimpleJdbcTemplate jdbcTemplate;
					public void setJdbcTemplate(SimpleJdbcTemplate jdbcTemplate) {
					this.jdbcTemplate = jdbcTemplate;
					}
				  }
				  
				  public void saveMotorist(Motorist motorist) {
				  
					jdbcTemplate.update(MOTORIST_INSERT, motorist.getEmail(), motorist.getPassword(), motorist.getFirstName(), motorist.getLastName());
					
				  }
					
				 The save method is not like JdbcTemplate save method instead its is of simplejdbc templete which take advantages of java 5.
				 
				 >> here we no need to convert the data types
				 >> RowMapper is generic we can work with specific class
				 
				 
				 
				 public Motorist getMotoristById(long id) {
						List<Motorist> matches = getSimpleJdbcTemplate().query(
						MOTORIST_BY_ID_SELECT,
						new ParameterizedRowMapper<Motorist>() {
								public Motorist mapRow(ResultSet rs, int rowNum)
								throws SQLException {
								Motorist motorist = new Motorist();
								motorist.setId(rs.getInt(1));
								motorist.setEmail(rs.getString(2));
								motorist.setPassword(rs.getString(3));
								motorist.setFirstName(rs.getString(4));
								motorist.setLastName(rs.getString(5));
								return motorist;
								}
							},
							id
						);
						return matches.size() > 0 ? matches.get(0) : null;
				  }
				  
				   
				  
				
//https://github.com/swarupmandal/programs.git
			  	